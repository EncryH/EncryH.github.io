---
layout: single
title: "🎮 C언어 테트리스 프로젝트"
categories: C
tag: [C언어 프로젝트]
toc: true
toc_label: 목차
author_profile: false
---

# 1학년 1학기 C언어 테트리스 콘솔 게임 

## 🛠 개발 환경 
● 언어(Language) : C<br/>
● 개발 도구(IDE) : Visual Studio<br/>
● 운영체제(OS) : Windows

## 설계 및 구조
● Main.c : 게임 루프 및 전체 흐름 제어<br/>
● Console.c : 콘솔 커서 제어 및 출력 관련 함수<br/>
● Data.c : 블록 데이터, 점수 처리<br/>
● Tetris.h : 전역 상수 및 함수 선언<br/>

## 핵심 기능 구현
### ✅ **자동 블록 하강** : 일정 시간마다 블록이 한 칸씩 내려감
```c
if (check_time()) // 화면갱신시간에 도달하면
		key = DOWNKEY; // 아래쪽으로 취급
```

### ✅ **좌우 이동 회전** : 방향키로 블록을 자유롭게 이동 및 회전 가능
```c
// 입력에 따라 블록을 이동하거나 회전
int process_event(int key)
{
	int addy; // 공백키 처리 변수
	int ret = 0; // 리턴값
	if (check_time()) // 화면갱신시간에 도달하면
		key = DOWNKEY; // 아래쪽으로 취급
	switch (key)
	{
	case RIGHTKEY:
		if (can_move(blockx + 1, blocky, current_block, block_rotation)) // 오른쪽으로 갈 수 있으면
		{
			delete_block(blockx, blocky, current_block, block_rotation); // 지우고
			blockx += 1; // 옮기고
			draw_block(blockx, blocky, current_block, block_rotation); // 다시 그림
		}
		break;
	case LEFTKEY:
		if (can_move(blockx - 1, blocky, current_block, block_rotation)) // 왼쪽으로 갈 수 있으면
		{
			delete_block(blockx, blocky, current_block, block_rotation); // 지우고
			blockx -= 1; // 옮기고
			draw_block(blockx, blocky, current_block, block_rotation); // 다시 그림
		}
		break;
	case UPKEY:
		if (can_move(blockx, blocky, current_block, (block_rotation + 1) % 4)) // 회전
		{
			delete_block(blockx, blocky, current_block, block_rotation); // 지우고
			block_rotation = (block_rotation + 1) % 4;
			draw_block(blockx, blocky, current_block, block_rotation); // 다시 그림
		}
		break;
	case DOWNKEY:
		if (can_move(blockx, blocky + 1, current_block, block_rotation)) // 아래쪽으로 갈 수 있으면
		{
			delete_block(blockx, blocky, current_block, block_rotation); // 지우고
			blocky = blocky + 1;
			draw_block(blockx, blocky, current_block, block_rotation); // 다시 그림
		}
		else // 블록이 맨밑이면
		{
			set_block(blockx, blocky, current_block, block_rotation);
			ret = 1; // 1 리턴
		}
		break;
	case SPACE:
		addy = blocky;

		do {
			addy = addy + 1;
		} while (can_move(blockx, addy, current_block, block_rotation));

		delete_block(blockx, blocky, current_block, block_rotation);
		blocky = addy - 1;
		draw_block(blockx, blocky, current_block, block_rotation);
		set_block(blockx, blocky, current_block, block_rotation);
		ret = 1;
	default:
		break;
	}
	return ret;
}
```

### ✅ **라인 삭제 기능** : 가득 찬 라인을 자동으로 삭제하고 점수를 계산
```c
// 게임판에서 한 줄 라인을 찾아 지우고, 점수 및 레벨을 업데이트
int check_line()
{
	int dlines = 0;
	int checky, checkx; // 게시판 좌표
	int filled; // 한 라인에 블럭 조각 채워진 수
	checky = blocky + 4; // 라인 검사 초기값

	do
	{
		if (checky >= PLATEY) // 라인이 바깥이면
			checky -= 1; // 한 줄 위를 검사
		else
		{
			filled = 0; // 라인 내 블럭 조각 수 0으로 초기화
			for (checkx = 1; checkx < PLATEX - 1; checkx++)
				if (game_plate[checky][checkx] == 1) // 한줄에 대하여 블록 조각 수를 셈
					filled += 1;
			if (filled == PLATEX - 2) // 한줄 다 채우면
			{
				move_block(checky); // 위쪽 블록을 옮김
				game_score += 10;
				dlines += 1;
			}
			else
				checky -= 1; // 아니면 윗줄 검사
		}

	} while (checky >= blocky);
	if (dlines > 0) // 지워진 라인이 한 개 이상이면
	{
		game_score += (dlines - 1) * 4;
		deleted_lines += dlines;
		game_level = deleted_lines / 4 + 1; // 게임 레벨 설정
		if (game_level > 9)
			game_level = 9;
		block_delay = 500 - (50 * (game_level - 1)); // 화면갱신 시간 조정
		print_score(game_score);
		print_level(game_level);

		if (game_high_score < game_score)
		{
			game_high_score = game_score;
		}
		print_high_score(game_high_score);
	}
	if ((checky <= 1) && (filled != 0))
		return 1;
	else
		return 0;
}
```

### ✅ **게임 오버 판정** : 블록이 화면 상단에 도달하면 게임 종료
```c
	if ((checky <= 1) && (filled != 0))
		return 1;
	else
		return 0;
```

### ✅ **최고 점수(High Score)** : 점수 저장 및 콘솔 화면에 출력
```c
void print_high_score(int high_score)
{
	char buf[10];

	sprintf(buf, "%4d", high_score);
	print_at(48, 20, buf);
}
```

### ✅ **NEXT 블럭 표시** : 다음에 나올 블럭을 오른쪽 패널에 시각적으로 출력
```c
// 다음에 블럭을 예상해서 출력
void get_nextblock()
{
	// 예고된 블록의 그림자를 지우고
	textcolor(15); delete_block(20, 8, next_block, 0);

	// 예고된 블록을 랜덤으로 설정하고 출력
	next_block = rand() % 18;
	textcolor(15); draw_block(20, 8, next_block, 0);
}
```

```c
// 다음 블럭 출력될 공간
char* nextblock[9] = {
	"  NEXT Block ",
	"■■■■■■■■■■■■■■■■■ ",
	"■               ■ ",
	"■               ■ ",
	"■               ■ ",
	"■               ■ ",
	"■               ■ ",
	"■               ■ ",
	"■■■■■■■■■■■■■■■■■ "
};
```

```c
// 다음 블럭, 초기화면, 점수 출력
void init_screen()
{
	int n = 0;

	for (n = 0; n < 9; n++)
	{
		textcolor(15); print_at(18 * 2, 5 + n, nextblock[n]); // 다음 블록 예고
		textcolor(15); print_at(28 * 2, 5 + n, gamemenu[n]); // 게임 메뉴
	}
	textcolor(15); print_at(18 * 2, 18, "     LEVEL : ");
	textcolor(15); print_at(18 * 2, 19, "     SCORE : ");
	textcolor(15); print_at(18 * 2, 20, "HIGH SCORE : ");
}
```

### ✅ **게임 시간 표시** : 플레이 타이머를 실시간으로 콘솔에 출력
```c
void myClock() {
	int hour = 0, minute = 0, second = 0, i = 0;

	while (1) {
		if (state != GAMEOVER) {
			second++;

			if (second == 60) {
				second = 0;
				minute++;
			}

			if (minute == 60) {
				minute = 0;
				hour++;
			}

			if (hour == 24) {
				hour = 0;
			}

			gotoxy(36, 0);
			printf("%02d:%02d:%02d", hour, minute, second);
			Sleep(1000);

			for (i = 1; i <= minute; i++) {
				if (game_score <= i * 100) {
					textcolor(12);
					print_at(8, 10, "※ GAME OVER ※");
					state = GAMEOVER;
					break;
				}
			}
		}
		else {
			if (key == ENTER) {
				hour = 0;
				minute = 0;
				second = 0;
			}
		}
	}
}
```

```c
HANDLE hClockThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)myClock, NULL, 0, NULL);
```

### ✅ **게임 레벨 및 속도 조절** : 점수 또는 라인 수에 따라 자동으로 속도 증가

### ✅ **텍스트 색상 적용** : 블럭과 UI 텍스트에 색상을 입혀 가독성 향상
```c
// 텍스트 색상을 변경하는 함수
// 윈도우즈 헤더파일 사용
void textcolor(int color_number) {
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color_number);
}
```
```c
// 색상을 나타내는 열거형 구조체
typedef enum Color {
	GRAY = 8,
	WHITE = 15
} COLOR;
```
```c
// 색상을 유지하면서 "■"을 출력하는 함수
void colorRetention(int colorType) {
	// 만약 colorType이 1이면
	if (colorType == 1) {
		textcolor(GRAY); // 텍스트 색상을 회색(GRAY)으로 변경
		printf("■");    // "■" 출력
		textcolor(WHITE); // 텍스트 색상을 흰색(WHITE)으로 변경
	}
}
```

### ✅ **제한 시간** : 제한 시간 안에 목표 점수 미달 시 게임 종료

### ✅ **그림자 블럭** : 블럭이 떨어질 위치를 미리 보여주어 사용자가 착지 위치를 판단할 수 있습니다.
```c
// 블록 그리기
void draw_block(int sx, int sy, int btype, int rotation)
{
	int bx, by;

	for (by = 0; by < 4; by++) // 블록내부 y축
		for (bx = 0; bx < 4; bx++) // 블록내부 x축
			if (tet_block[btype][rotation][by][bx] == 1) // 값이 1인 위치에
				PUT_BS(2 * (sx + bx), sy + by); // 검은 블록

	// 그림자 블록 그리기
	if (sx != 20 || sy != 8) {
		if (can_move(sx, sy + 1, btype, rotation)) {
			shadow_blockx = sx; // 그림자의 x좌표는 현재 블록의 x좌표와 동일하게 설정
			shadow_blocky = sy;

			while (can_move(shadow_blockx, shadow_blocky + 1, btype, rotation)) {
				shadow_blocky++; // 그림자를 아래로 이동
			}

			// 메뉴 창 영역을 벗어나는지 확인 후 그리기
			for (by = 0; by < 4; by++)
				for (bx = 0; bx < 4; bx++)
					if (tet_block[btype][rotation][by][bx] == 1)
						PUT_SS(2 * (shadow_blockx + bx), shadow_blocky + by);
		}
	}

}

// 블록 지우기
void delete_block(int sx, int sy, int btype, int rotation)
{
	int bx, by;

	for (by = 0; by < 4; by++) // 블록내부 y축
		for (bx = 0; bx < 4; bx++) // 블록내부 x축
			if (tet_block[btype][rotation][by][bx] == 1) // 값이 1인 위치에
				print_at(2 * (sx + bx), sy + by, "  "); // 공백 출력

	// 그림자 블럭 삭제
	if (sx != 20 || sy != 8) {
		shadow_blockx = sx; // 그림자의 x좌표는 현재 블록의 x좌표와 동일하게 설정
		shadow_blocky = sy;

		while (can_move(shadow_blockx, shadow_blocky + 1, btype, rotation)) {
			shadow_blocky++; // 그림자를 아래로 이동
		}

		for (by = 0; by < 4; by++)
			for (bx = 0; bx < 4; bx++)
				if (tet_block[btype][rotation][by][bx] == 1)
					print_at(2 * (shadow_blockx + bx), shadow_blocky + by, "  "); // 블록을 삭제하는 함수 호출 (적절한 함수명으로 변경 필요)
	}
}
```

## 디버깅 [게임 시간 표시 시 메인 루프 정지 에러]
게임 내 시간을 표시하는 코드를 추가 중에 게임 시작시 콘솔창이 멈추는 에러가 발생

### 점유된 스레드 
<video src="C:/khm35/OneDrive/Desktop/Github Page Blog/C/그냥 호출.mp4" controls=""></video>

게임 내 시간을 표시하기 위해 myClock() 함수를 호출했을 때, 해당 함수 내부의 무한 루프가 메인 스레드를 점유해버림

![쓰레드 코드](/image/2025-08-12-Tetris/쓰레드 코드.png)

myClock() 함수를 메인 루프와 동시에 실행할 수 있도록, CreateThread()를 사용하여 별도의 스레드로 실행되도록 수정<br/>

이를 통해 메인 스레드는 게임 진행(입력·이동·화면 갱신)을 담당하고, 보조 스레드는 경과 시간을 독립적으로 측정 및 출력하게 됨

### 정상적으로 실행되는 스레드
<video src="C:/khm35/OneDrive/Desktop/Github Page Blog/C/스레드 호출.mp4" controls=""></video>

<!-- ```c
// myClock 함수를 쓰레드로 실행
HANDLE hClockThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)myClock, NULL, 0, NULL);
``` -->

## 실행 화면

### 시작화면

![Tetris_Game 콘솔창 메인 실행 창](/image/2025-08-12-Tetris/Tetris_Game 콘솔창 메인 실행 창.png)

### 게임 중 화면

![Tetris_Game 실행 화면](/image/2025-08-12-Tetris/Tetris_Game 실행 화면.png)
